### JPA에서 가장 중요한 2가지
객체와 관계형 데이터베이스 매핑하기, 영속성 컨텍스트

<br>

## 영속성 컨텍스트
#### 엔티티 매니저 팩토리와 엔티티 매니저
고객이 요청 올 때마다 엔티티 매니저 팩토리에서 엔티티 매니저를 생성 <br>
팩토리는 내부적으로 커넥션 풀 생성

<br>

#### 영속성 컨텍스트 : 엔티티를 영구 저장하는 환경
- `EntityManager.persist(entity);`
- 논리적인 개념으로 눈에 안보임
- 엔티티 매니저로 영속성 컨텍스트에 접근

<br>

#### 앤티티 생명주기 
- 비영속(생성)
- 영속(관리되는 상태, persist)
- 준영속(저장되었다가 분리된 상태, detach)
- 삭제 

영속 persist로 DB 바로 저장되는 것 X -> 트랜잭션 커밋하는 시점에 쿼리 전달

<br>

#### 영속성 컨텍스트 이점
> **1차 캐시 없음 -> DB 조회 -> 조회한 것을 1차 캐시에 저장 -> 저장한 것 반환**
>
> 엔티티를 조회할 때 DB가 아닌 1차 캐시를 먼저 조회

- 짧은 순간 찰나에 이득 -> DB 한 트랜잭션 내에서 이득 (비즈니스 로직 복잡할 때 도움)
- 1차 캐시 -> 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 애플리케이션 차원에서 제공
- 트랜잭션 지원하는 쓰기 지연-> persist로 1차 캐시 저장 동시에 쓰기 지연 저장소에도 저장 (플러시를 통해 DB 최종 저장)
- 엔티티 수정 변경 감지 -> Dirty Checking 기능 제공 (값 변경시 트랜잭션이 커밋되는 시점에 변경을 반영함)

<br>

## 플러시
> 플러시 -> 엔티티와 스냅샷(값을 처음 읽어온 시점의 상태) 비교 -> 업데이트 쿼리문 생성 -> 플러시 -> 커밋
>
> **영속성 컨텍스트의 변경 내용을 DB에 반영**
- 변경 감지
- 수정된 엔티티 쓰기 지연 sql 저장소에 등록
- 쓰기 지연 sql 저장소의 쿼리를 데이터베이스에 저장
-> 수정, 변경된 sql 쿼리를 데이터베이스에 반영하는 과정

<br>

방법
1.	em.flush()
2.	트랜잭션 커밋
3.	JPQL 쿼리 실행 (쿼리 실행 전 무조건 플러시 실행)

<br>

플러시는 <br> 
    영속성 컨텍스트를 비우지 않고, <br>
	영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하며,<br>
	트랜잭션이라는 작업 단위가 중요하기에 커밋 직전에만 동기화하면 된다.

<br>

## 준영속 상태
영속 -> 준영속 <br>
영속 상태의 엔티티가 영속성 컨텍스트에서 분리되어 제공하는 기능을 사용 못함

방법
1.	em.detach(Entity) :  특정 엔티티만 준영속 상태로 전환
2.	em.clear() : 영속성 컨텍스트를 완전히 초기화
3.	em.close() : 영속성 컨텍스트를 종료