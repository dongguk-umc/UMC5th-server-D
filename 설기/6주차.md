### 프록시
Member 조회시 연관관계 걸려있는 데이터 다 가져오기엔 손해 -> 프록시

<br>

#### 프록시
> em.find() vs em.getReference()
> - em.find(): 데이터베이스를 통해 실제 엔티티 객체 조회
> - em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

- 실제 클래스를 상속 받아서 만들어짐, 실제 객체의 참조(target)를 보관
- 실제 클래스와 겉 모양이 같음
- 사용하는 입장에서는 진짜/프록시 객체인지 구분 안하고 사용해도 됨
- 프록시 객체 호출시 프록시 객체는 실제 객체의 메소드 호출
- 프록시 객체 초기화 (처음 사용할 때 한번만 초기화)
    1. getReference() 메서드 호출
    2. 영속성 컨텍스트 초기화 요청
    3. DB 조회
    4. 실제 Entity 생성
    5. target.getReference() 호출

<br>

#### 프록시 특징
- 프록시 객체 초기화시 프록시 객체가 실제 엔티티로 바뀌는 것이 아니라 **초기화되면 프록시 객체를 통해 실제 엔티티에 접근 가능**
- 프록시는 원본 엔티티 상속 -> 타입 체크시 유의 (== 비교 실패, 대신 instance of 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환 (그 반대도 -> JPA에서 == true되게끔 최대한 보장)
- 준영속 상태(영속성 컨텍스트 관리 X)일 때 프록시 초기화시 문제 발생

<br>

### 즉시 로딩과 지연 로딩
#### 지연 로딩
- 지연로딩 LAZY를 사용해서 프록시로 조회
    ex) @ManyToOne(fetch = FetchType.LAZY)
    1. 로딩 
    2. 지연로딩 LAZY
    3. 프록시 조회
- xxx.getReference() -> 실제 xxx를 사용하는 시점에 초기화

<br>

#### 즉시 로딩
- A, B entity 를 자주 같이 쓴다면 즉시로딩으로
- JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회

<br>

#### **주의사항**
- 가급적 지연 로딩만 사용 (특히 실무에서)
- 즉시로딩 사용시 예상치 못한 SQL 발생
    - JPQL에서 **N+1** 문제 일으킴 -> 처음 쿼리 1번 날렸을 때 추가 쿼리가 N개 발생
    - ex) 각기 팀이 다른 멤버들 조회 -> 멤버들 다 조회 후 멤버별로 속한 각기 팀도 조회
        - 지연로딩으로 변경시 팀은 프록시로
- **@ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 꼭 설정하기**
- @OneToMany, @ManyToMany는 기본이 지연 로딩 

<br>

### 영속성 전이(CASCADE)와 고아 객체
#### 영속성 전이(CASCADE)
- 특정 엔티티를 영속 상태로 만들고 싶을 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때!
    ex) 부모 엔티티 저장시 자식 엔티티도
- @OneToMany(..., cascade = CascadeType.PERSIST)
- 영속성 전이는 연관관계 매핑과 관련 X
- 엔티티 영속화할 때 연관관계에 있는 엔티티도 영속화함
    - ALL: 모두 적용
    - PERSIST: 영속
    - REMOVE: 삭제

<br>

#### 고아 객체
- 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
    - orphanRemoval = True
- 함부로 쓰면 큰일! => 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
- **참조하는 곳이 하나일 때 사용!**
- **특정 엔티티가 개인 소유할 때 사용**
- @OneToOne, @OneToMany 만 가능
- Cascade.REMOVE 처럼 작동함

<br>

#### 영속성 전이 + 고아 객체, 생명 주기
> CascadeType.ALL + orphanRemoval=true
- 스스로 생명주기 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
- 두 옵션 모두 활성화시 부모 엔티티를 통해 자식의 생명주기 관리 가능 (DAO나 Repository 없이도 가능)
- 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용