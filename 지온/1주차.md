### JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기(정적)
    - DB와 객체의 설계에서 중간다리인 JPA와의 매핑 방식 등
- 내부 동작 방식(동적)
    - 영속성 컨텍스트
 
### 영속성 컨텍스트

- 엔티티를 영구 저장하는 환경 - EntityManager.persist(entity);
- 논리적인 개념으로, 눈에 보이지 않음
- 엔티티 매니저를 통해 영속성에 접근
    - 엔티티 매니저 안에 영속성 컨텍스트라는 공간이 생성됨
- DB와 Application 사이의 중간 계층이 있는 것이며, 이 계층을 통해 큰 이점을 얻어냄
 
### 엔티티의 생명주기

- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
    - 객체를 생성한 상태(JPA와 관련이 없는 상태)
- 영속(managed): 영속성 컨텍스트에 관리되는 상태
    - 영속 컨텍스트(entityManager) 내부에 들어가면서 영속된 상태
    - 아직 DB에 저장된 상태는 아니기에, DB에 저장이 되려면 persist() 이후 transaction.commit()이 필요
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 영속성 컨텍스트에서 분리시킨 상태
- 삭제(removed): 삭제된 상태
    - DB 삭제를 요청한 상태(영구저장을 DB에서 지움)
 
### 1차 캐시, 엔티티 조회

- 엔티티 조회 시 영속성 컨텍스트 내부의 1차 캐시에서 조회
- 1차 캐시에 없다면 DB를 조회하고 1차 캐시에 저장한 후, 반환
- 사실… 일반적으로는 큰 도움은 안됨 → EntityManager는 DataBase Transaction 단위로 만들어져 트랜잭션 종료시 종료되기 때문
- 성능의 이점보다는 객체 지향적 코드를 작성하는 측면에서 컨셉의 이점이 존재함

### 영속 엔티티의 동일성 보장

- == 비교를 보장해줌
- Java Collection에서 똑같은 레퍼런스가 있는 객체를 꺼내는 것과 동일
- 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

### 엔티티 등록 시 트랜잭션을 지원하는 쓰기 지원

- 영속 컨텍스트 안에 쓰기 지연 SQL 저장소가 존재
- em.persist();는 영속 컨텍스트 내에서 쓰기 지연 SQL 저장소에 INSERT SQL을 생성한 후 쌓아두고, 1차 캐시에 해당 객체를 저장함
- 이후, transaction.commit();은 SQL 저장소에 존재하는 쿼리가 DB에 날라가고(flush), 실제 DB 트랜잭션이 commit됨
- 즉, 커밋을 하는 시점에 DB로 쿼리가 날라감
- 쓰기 지연 SQL 저장소가 존재하지 않고 persist하는 즉시 db에 쿼리를 날린다면 성능을 최적화할 수 있는 부분이 없음

### 엔티티 수정, 변경 감지

- Java Collection처럼 다룬다 → 수정된 값을 다시 넣거나 하지 않음
- JPA는 커밋을 하면 영속 컨텍스트 내부에서 1.flush() 호출, 2.엔티티와 스냅샷을 비교, 3.update sql 생성
    - 스냅샷이라는 것은 값을 읽어온 시점을 저장한 것으로, 내부적으로 Entity와 스냅샷을 비교함
    - 만약 다르다면 쓰기 지연 SQL 저장소에 update sql 저장

### 플러시

- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영
- 언제 발생?
    - 변경 감지
    - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
    - 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)
- 영속성 컨텍스트를 플러시하는 방법
  - em.flush() - 직접 호출
  - 트랜잭션 커밋 - 플러시 자동 호출
  - JPQL 쿼리 실행 - 플러시 자동 호출
- 특징
  - 영속성 컨텍스트를 비우지 않음(1차 캐시 유지)
  - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
  - 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면 됨
 
### 준영속 상태
- 영속성 컨텍스트가 제공하는 기능(dirty checking 등)을 사용하지 못함
- 영속성 컨텍스트로부터 분리함, 더 이상 관리하지 않겠다는 뜻

### :seedling: 궁금증 정리
어떤 상황에서 준영속 상태가 필요할까?
- :bulb: 장기 실행 트랜잭션…? 긴 트랜잭션 동안 많은 데이터를 처리해야 한다면… 메모리 사용량으로 인해 모든 변경을 영속성 컨텍스트에서 추적하기 어려울 거 같다.
이 경우, 엔티티를 준영속 상태로 만들면 영속성 컨텍스트의 부하를 줄일 수 있어서 필요하지 않을까?
- :mag: 스프링과 JPA를 함께 사용하면 보통 트랜잭션을 서비스 계층까지만 유지하고, 영속성 컨텍스트도 거기에 맞추어 서비스 계층까지만 유지한다.
이 경우, 컨트롤러에서는 영속성 컨텍스트가 존재하지 않기 때문에 엔티티가 준영속 상태가 되므로, 실무에서는 매우 자주 발생하는 일이다.

SQL 저장소에 모았다가 한 번에 보내는 것이 유의미한 성능 차이를 보일까?
- :mag: 변경이 발생할 경우, 마지막 변경만 데이터베이스에 반영되어 불필요한 SQL 실행을 줄여주긴 하지만 주요 성능 차이는 데이터베이스와 네트워크 지연에서 발생한다.
애플리케이션과 DB간의 연결 및 전송의 과정에서 네트워크 지연이 발생하기 때문에 성능에 영향이 있는 것으로, 네트워크 지연의 정도가 클수록 영향도 커진다.
