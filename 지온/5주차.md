### 상속관계 매핑

- 관계형 데이터베이스는 상속 관계 x
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
    - 조인 전략: 각각 테이블로 변환
    - 단일 테이블 전략: 통합 테이블로 변환
    - 구현 클래스마다 테이블 전략: 서브타입 테이블로 변환
- 상속관계 매핑: 객체의 상속과 구조를 db의 슈퍼타입 서브타입 관계로 매핑
- JPA를 사용하면 전략 변경이 큰 수정사항 없이 이루어질 수 있음

### 조인 전략

- 상속받는 각 클래스에 대한 테이블을 생성하고, 조회 시 조인 연산을 사용
- @Inheritance(strategy = InheritanceType.JOINED)
- @DiscriminatorValue(””)를 통해 슈퍼타입 테이블에 저장되는 서브타입의 값 지정 가능
    - 하위 클래스에 선언
- @DiscriminatorColumn(name=”DTYPE”)
    - 부모 클래스에 선언
    - 하위 클래스를 구분하는 용도의 컬럼(default=DTYPE)
 
### 조인 전략 장단점

- 장점
    - 테이블 정규화
    - 외래 키 참조 무결성 제약조건 활용가능
    - 저장공간 효율화
    - 설계 입장에서 깔끔함
- 단점
    - 조회시 조인을 많이 사용, 성능 저하
    - 조회 쿼리가 복잡함
    - 데이터 저장시 insert sql 2번 호출

### 단일 테이블 전략

- 모든 클래스에 대한 데이터를 단일 테이블에 저장
- 구분 컬럼(Discriminator Column)을 사용하여 각 행이 어떤 클래스의 인스턴스인지 식별
- @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    - defualt

### 단일 테이블 전략 장단점

- 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용 → 치명적인 단점(데이터 무결성 위배)
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있어 상황에 따라 조회 성능이 오히려 느려질 수 있다.(드문 상황)

### 구현 클래스마다 테이블 전략

- 각 구현 클래스마다 별도의 테이블을 생성하지만, 상위 클래스는 테이블을 가지지 않음
- 즉, 슈퍼타입을 제거하고 서브타입에 그 속성들을 추가함
- @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
- 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략
 
### 구현 클래스마다 테이블 전략 장단점

- 장점
    - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    - not null 제약조건 사용 가능
- 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL)
    - 자식 테이블을 통합해서 쿼리하기 어려움

### 전략 선택

- 조인 전략의 장단점과 단일 테이블 전략의 장단점 사이의 Trade Off를 고민하는 것이 중요
- 조인 전략을 기본으로 두고 만약, 확장 가능성이 거의 없고 단순한 구조라면 이때, 단일 테이블 전략 적용
    - 비즈니스적으로 중요하고 복잡하다면 그대로 조인 전략 유지

### @MappedSuperClass

- 공통 매핑 정보가 필요할 때 사용(id, name)
- 상속관계 매핑x, 엔티티x, 테이블과 매핑x
- 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가(em.find(BaseEntity) 불가)
- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

  
