### 프록시 기초

- em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    - DB 쿼리는 안나가는데 객체는 조회

### 프록시 객체의 초기화

- 영속성 컨텍스트를 통해서 db를 조회하고 실제 entity를 생성해서 전달 → 초기화
  - 초기화: db로부터 값을 가져와서 진짜 entity를 만드는 과정

### 프록시의 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 떄, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
    - 프록시 객체가 실제 객체로 교체되는 게 아니라 프록시 객체의 값이 채워지는 것
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야 함(== 비교 실패, 대신 Instance of 사용)
    - 프록시랑 프록시가 아닌 멤버는 타입이 다를 수 있음
    - jpa에서는 프록시를 구분하기 어려우니(값이 실제인지 프록시인지 확인 어려움) 그냥 왠만하면 instance of를 사용, ==는 지양
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
    - 영속성 컨텍스트에 이미 엔티티를 올려놨다면, 프록시를 가져와봐야 이점이 없음 → 원본 반환이 성능 최적화의 관점에서 좋음
    - em.getReference() → em.find() 순서로 진행한다면 ==를 보장하기 위해 em.find()로 가져온 객체 역시 프록시 객체
    - 중요한 포인트는 개발 시 객체가 프록시든 실제 객체든 문제 없게 개발하는 것
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생

### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인
    - PersistenceUnitUtil.isLoaded(Object entity)
- 프록시 클래스 확인 방법
    - entity.getClass().getName() 출력
- 프록시 강제 초기화
    - org.hibernate.Hibernate.initialize(entity)
- 참고: JPA 표준은 강제 초기화 없음
    - 강제 호출: member.getName()

### 로딩 전략

- @ManyToOne(fetch = FetchType.LAZY) : 지연 로딩
  - One 엔티티에 대해 프록시 객체를 생성, 실제 해당 엔티티의 값을 사용하는 시점에 초기화(DB조회)
- @ManyToOne(fetch = FetchType.EAGER) : 즉시 로딩
  - Many 엔티티를 사용할 때 One 엔티티를 조인하여 한 번에 조회

### 로딩 전략 활용 - 이론

- Member(Many)와 Team(One)은 자주 함께 사용 → 즉시 로딩
- Member(One)와 Order(Many)는 가끔 사용 → 지연 로딩
- Order(Many)와 Product(One)은 자주 함께 사용 → 즉시 로딩

### 로딩 전략 활용 - 실무

- 모든 연관관계에 지연 로딩을 사용할 것(즉시 로딩은 사용 금지)
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용할 것
- 즉시 로딩은 상상하지 못한 쿼리가 나감

### 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때
- ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장
- @OneToMany(mappedBy=”parent”, cascade=CascadeType.PERSIST)

### 영속성 전이: CASCADE - 주의

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐
- 단일 엔티티에서 종속적일 때 사용, 그 외에는 복잡해짐
    - parent와 child의 life cycle이 동일할 때
    - 단일 소유주, 즉, parent라는 엔티티만 child를 소유할 때

### 고아 객체

- 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval = true
- Parent parent1 = em.find(Parent.class, id);

### 고아 객체 - 주의

- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
- 참조하는 곳이 하나일 때 사용해야 함
    - 게시글-첨부파일 관계와 같은 경우
- 특정 엔티티가 개인 소유할 때 사용
- @OneToOne, @OneToMany만 가능

### 영속선 전이 + 고아 객체, 생명주기

- CascadeType.ALL + orphanRemoval=true
- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음
- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용
